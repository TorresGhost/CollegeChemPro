%%
%% This is file `spath.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% spath.dtx  (with options: `package')
%% ----------------------------------------------------------------
%% spath --- Functions for manipulating PGF soft paths
%% E-mail: stacey@math.ntnu.no
%% Released under the LaTeX Project Public License v1.3c or later
%% See http://www.latex-project.org/lppl.txt
%% ----------------------------------------------------------------
%% 
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{spath}[2011/06/03 v1.0 Functions for manipulating PGF soft paths]
\usepgfmodule{oo}
\long\def\ge@addto@macro#1#2{%
  \begingroup
  \toks@\expandafter\expandafter\expandafter{\expandafter#1#2}%
  \xdef#1{\the\toks@}%
  \endgroup}

\def\tikz@clear@foreach{%
\let\pgffor@beginhook=\pgfutil@empty
\let\pgffor@endhook=\pgfutil@empty
\let\pgffor@afterhook=\pgfutil@empty
}

\long\def\ge@addbefore@macro#1#2{%
  \begingroup
  \toks@\expandafter\expandafter\expandafter{\expandafter#2#1}%
  \xdef#1{\the\toks@}%
  \endgroup}
\long\def\g@addbefore@macro#1#2{%
  \def\@temp{#2}%
  \ge@addbefore@macro{#1}{\@temp}}
\tikzset{%
  use path/.code={%
    \pgfsyssoftpath@setcurrentpath{#1}%
  }
}
\pgfooclass{spath}{
  \attribute path;
  \attribute length;
  \attribute real length;
  \attribute number of components;
  \attribute initial point;
  \attribute final point;
  \attribute first action;
  \attribute last action;
  \attribute prepared;
  \attribute taper line width;
  \attribute min bb;
  \attribute max bb;
  \attribute scratch pad;
  \method spath(#1) {%
    \let\spath@temp=#1\relax
    \ifx\spath@temp\relax
    \else
     \pgfoolet{path}{#1}%
    \fi
  }
  \method use current path() {%
    \pgfsyssoftpath@getcurrentpath{\spath@temp}%
    \pgfoolet{path}{\spath@temp}%
    \let\spath@temp=\pgfutil@empty
  }
  \method value(#1) {%
    \pgfoovalueof{#1}%
  }
  \method set(#1,#2) {%
    \pgfooset{#1}{#2}%
  }
  \method let(#1,#2) {%
    \pgfoolet{#1}{#2}%
  }
  \method set if not empty(#1,#2) {%
  \pgfooget{#1}{\spath@tmp}%
  \ifx\spath@tmp\pgfutil@empty
    \pgfooset{#1}{#2}%
  \fi
  }
  \method let if not empty(#1,#2) {%
  \pgfooget{#1}{\spath@tmp}%
  \ifx\spath@tmp\pgfutil@empty
    \pgfoolet{#1}{#2}%
  \fi
  }
  \method get(#1,#2) {%
    \pgfooget{#1}{#2}%
  }
  \method show(#1) {%
    \pgfooget{#1}{\@temp}%
    \show\@temp
  }
  \method what am I() {%
     \message{I am an spath object}%
  }
  \method clone(#1) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \else
     \pgfoonew \spath@newpath =new spath()%
  \tikz@clear@foreach
     \foreach \attribute in {
      path,
      length,
      real length,
      number of components,
      initial point,
      final point,
      first action,
      last action,
      prepared,
      taper line width,
      min bb,
      max bb%,
     } {
      \pgfooget{\attribute}{\spath@temp}%
      \spath@newpath.let(\attribute,\spath@temp)%
    }
    \let#1=\spath@newpath%
    \fi
  }
  \method translate path(#1,#2,#3) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \spath@trx=#2\relax
     \spath@try=#3\relax
     \spath@translate@init
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
     \let\spath@tmppath=\pgfutil@empty
  \tikz@clear@foreach
     \foreach \attribute in {
      initial point,
      final point,
      min bb,
      max bb%,
     } {
      \pgfooget{\attribute}{\spath@temp}%
      \ifx\spath@temp\pgfutil@empty
      \else
       \spath@temp
       \advance\pgf@x by \spath@trx\relax
       \advance\pgf@y by \spath@try\relax
       \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@x}{\the\pgf@y}}%
       \pgfoolet{\attribute}{\spath@temp}%
      \fi
    }
    \endgroup
    \let\spath@tmppath=\pgfutil@empty
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.translate path(,#2,#3)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method transform path(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \pgftransformreset
     \pgfsettransform{#2}%
     \spath@transform@init
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
     \let\spath@tmppath=\pgfutil@empty
  \tikz@clear@foreach
     \foreach \attribute in {
      initial point,
      final point,
      min bb,
      max bb,
      prepared%,
     } {
      \pgfoolet{\attribute}{\pgfutil@empty}%
     }%
    \endgroup
    \let\spath@tmppath=\pgfutil@empty
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.transform path(,#2)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method scale path(#1,#2,#3) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \edef\spath@scx{#2}%
     \edef\spath@scy{#3}%
     \ifx\spath@scy\pgfutil@empty
      \edef\spath@scy{#2}%
     \fi
     \spath@scale@init
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
     \let\spath@tmppath=\pgfutil@empty
  \tikz@clear@foreach
     \foreach \attribute in {
      initial point,
      final point,
      min bb,
      max bb%,
     } {
      \pgfooget{\attribute}{\spath@temp}%
      \ifx\spath@temp\pgfutil@empty
      \else
       \spath@temp
       \pgf@x=\spath@scx\pgf@x\relax
       \pgf@y=\spath@scy\pgf@y\relax
       \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@x}{\the\pgf@y}}%
       \pgfoolet{\attribute}{\spath@temp}%
      \fi
    }
    \endgroup
    \let\spath@tmppath=\pgfutil@empty
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.scale path(,#2,#3)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method round corners(#1,#2,#3) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \spath@round@init
     \edef\spath@rndx{#2}%
     \edef\spath@rndy{#3}%
  \ifx\spath@rndy\pgfutil@empty
   \let\spath@rndy\spath@rndx
  \fi
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
    \endgroup
     \pgfooget{path}{\spath@tmppath}%
     \pgfprocessround\spath@tmppath\spath@temppath
     \pgfoolet{path}{\spath@temppath}%
   \else
    \pgfooget{path}{\spath@tmppath}%
    \spath@newpath =new spath(\spath@tmppath)%
    \begingroup
    \spath@newpath.round corners(,#2)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method shrink path(#1,#2,#3,#4) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \spath@trx=#2\relax
     \spath@try=#3\relax
     \edef\spath@shrinkby{#4}%
     \spath@shrink@init
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
     \let\spath@tmppath=\pgfutil@empty
  \tikz@clear@foreach
     \foreach \attribute in {
      initial point,
      final point,
      min bb,
      max bb%,
     } {
      \pgfooget{\attribute}{\spath@temp}%
      \ifx\spath@temp\pgfutil@empty
      \else
       \spath@temp
       \pgfmathsetlength{\pgf@xa}{\pgf@x < \spath@trx ? \pgf@x + \spath@shrinkby : (\pgf@x > \spath@trx ? \pgf@x - \spath@shrinkby : \pgf@x)}%
       \pgfmathsetlength{\pgf@ya}{\pgf@y < \spath@try ? \pgf@y + \spath@shrinkby : (\pgf@y > \spath@try ? \pgf@y - \spath@shrinkby : \pgf@y)}%
       \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@xa}{\the\pgf@ya}}%
       \pgfoolet{\attribute}{\spath@temp}%
      \fi
    }
    \endgroup
    \let\spath@tmppath=\pgfutil@empty
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.shrink path(,#2,#3)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method prepare spirograph(#1,#2,#3,#4) {%
    \pgfoothis.prepare()%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \spath@trx=#2\relax
     \spath@try=#3\relax
     \def\spath@n{0}%
     \pgfooget{length}{\spath@temp}%
     \pgfmathsetmacro{\spath@gang}{#4/(\spath@temp-1)}%
     \spath@spirograph@init
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
     \let\spath@tmppath=\pgfutil@empty
     \pgfooget{final point}{\spath@temp}%
     \ifx\spath@temp\pgfutil@empty
     \else
      \spath@temp
      \pgf@xa=\pgf@x\relax
      \pgf@ya=\pgf@y\relax
      \advance\pgf@xa by -\spath@trx\relax
      \advance\pgf@ya by -\spath@try\relax
      \pgfmathsetmacro{\spath@gcos}{cos(#4)}%
      \pgfmathsetmacro{\spath@gsin}{sin(#4)}%
      \pgfmathsetlength{\pgf@xb}{\spath@gcos * \pgf@xa - \spath@gsin * \pgf@ya}%
      \pgfmathsetlength{\pgf@yb}{\spath@gsin * \pgf@xa + \spath@gcos * \pgf@ya}%
      \advance\pgf@xb by \spath@trx\relax
      \advance\pgf@yb by \spath@try\relax
      \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@xb}{\the\pgf@yb}}%
      \pgfoolet{final point}{\spath@temp}%
     \fi
    \endgroup
    \let\spath@tmppath=\pgfutil@empty
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.prepare spirograph(,#2,#3,#4)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
\method spirograph(#1,#2,#3,#4) {
    \pgfoothis.prepare()%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \begingroup
     \pgfmathsetmacro{\spath@gn}{360/#4}%
     \pgfoothis.prepare spirograph(,#2,#3,\spath@gn)%
     \pgfoothis.clone(\spath@tempa)%
     \pgfmathsetmacro{\spath@gna}{2*\spath@gn}%
     \pgfmathsetmacro{\spath@gnb}{360-\spath@gn}%
  \tikz@clear@foreach
     \foreach \k in {\spath@gn,\spath@gna,...,\spath@gnb} {%
      \spath@tempa.rotate path(,\spath@gn)%
      \pgfoothis.weld(,\spath@tempa)%
     }%
    \endgroup
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.spirograph(,#2,#3,#4)%
    \endgroup
    \let#1=\spath@newpath
   \fi
}
  \method rotate path(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \pgfmathsetmacro{\spath@gcos}{cos(#2)}%
     \pgfmathsetmacro{\spath@gsin}{sin(#2)}%
     \spath@rotate@init
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
     \let\spath@tmppath=\pgfutil@empty
     \pgfooget{initial point}{\spath@temp}%
     \ifx\spath@temp\pgfutil@empty
     \else
      \spath@temp
      \pgf@xa=\pgf@x\relax
      \pgf@ya=\pgf@y\relax
      \pgfmathsetlength{\pgf@xb}{\spath@gcos * \pgf@xa - \spath@gsin * \pgf@ya}%
      \pgfmathsetlength{\pgf@yb}{\spath@gsin * \pgf@xa + \spath@gcos * \pgf@ya}%
      \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@xb}{\the\pgf@yb}}%
      \pgfoolet{initial point}{\spath@temp}%
     \fi
     \pgfooget{final point}{\spath@temp}%
     \ifx\spath@temp\pgfutil@empty
     \else
      \spath@temp
      \pgf@xa=\pgf@x\relax
      \pgf@ya=\pgf@y\relax
      \pgfmathsetlength{\pgf@xb}{\spath@gcos * \pgf@xa - \spath@gsin * \pgf@ya}%
      \pgfmathsetlength{\pgf@yb}{\spath@gsin * \pgf@xa + \spath@gcos * \pgf@ya}%
      \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@xb}{\the\pgf@yb}}%
      \pgfoolet{final point}{\spath@temp}%
     \fi
    \endgroup
    \let\spath@tmppath=\pgfutil@empty
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.rotate path(,#2)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method length() {%
    \pgfooget{length}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \setcounter{spath@length}{0}%
    \begingroup
    \spath@length@init
    \pgfoovalueof{path}%
    \endgroup
     \edef\spath@temp{\the\value{spath@length}}%
     \pgfoolet{length}{\spath@temp}%
    \fi
    \spath@temp
  }
  \method real length() {%
    \pgfooget{real length}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \setcounter{spath@length}{0}%
    \begingroup
    \spath@reallength@init
    \pgfoovalueof{path}%
    \endgroup
     \edef\spath@temp{\the\value{spath@length}}%
     \pgfoolet{real length}{\spath@temp}%
    \fi
    \spath@temp
  }
  \method number of components() {%
    \pgfooget{number of components}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \setcounter{spath@length}{0}%
    \begingroup
    \spath@components@init
    \pgfoovalueof{path}%
    \endgroup
     \edef\spath@temp{\the\value{spath@length}}%
     \pgfoolet{real length}{\spath@temp}%
    \fi
    \spath@temp
  }
  \method initial point() {%
    \pgfooget{initial point}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \begingroup
    \spath@start@init
    \pgfoovalueof{path}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@sx}{\spath@sy}}%
    \pgfoolet{initial point}{\spath@temp}%
    \endgroup
    \pgfooget{initial point}{\spath@temp}%
    \fi
    \spath@temp
  }
  \method final point() {%
    \pgfooget{final point}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \begingroup
    \spath@end@init
    \pgfoovalueof{path}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@ex}{\spath@ey}}%
    \pgfoolet{final point}{\spath@temp}%
    \endgroup
    \pgfooget{final point}{\spath@temp}%
    \fi
    \spath@temp
  }
  \method bounding box() {%
    \pgfooget{min bb}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \else
     \pgfooget{min bb}{\spath@temp}%
    \fi
    \ifx\spath@temp\pgfutil@empty
     \begingroup
      \spath@boundingbox@init
      \pgfoovalueof{path}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{min bb}{\spath@temp}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@max}{\spath@may}}%
      \pgfoolet{max bb}{\spath@temp}%
     \endgroup
    \fi
  }
  \method min bb() {%
    \pgfooget{min bb}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
     \pgfoothis.bounding box()%
     \pgfooget{min bb}{\spath@temp}%
    \fi
    \spath@temp
  }
  \method max bb() {%
    \pgfooget{max bb}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
     \pgfoothis.bounding box()%
     \pgfooget{max bb}{\spath@temp}%
    \fi
    \spath@temp
  }
  \method mid point() {%
    \pgfoothis.min bb()%
    \pgf@xa=.5\pgf@x
    \pgf@ya=.5\pgf@y
    \pgfoothis.max bb()%
    \pgf@x=.5\pgf@x
    \pgf@y=.5\pgf@y
    \advance\pgf@xa by \pgf@x
    \advance\pgf@ya by \pgf@y
    \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@xa}{\the\pgf@ya}}%
    \spath@temp
  }
  \method reverse path(#1) {%
   \let\spath@newpath=#1\relax
   \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \pgfoothis.prepare()%
    \begingroup
    \spath@reverse@init
    \pgfoovalueof{path}%
    \g@addbefore@macro\spath@tmppath\pgfsyssoftpath@movetotoken
    \endgroup
    \pgfoolet{path}{\spath@tmppath}%
    \pgfooget{initial point}{\spath@temp}%
    \pgfooget{final point}{\spath@tempa}%
    \pgfoolet{final point}{\spath@temp}%
    \pgfoolet{initial point}{\spath@tempa}%
    \pgfooget{first action}{\spath@temp}%
    \pgfooget{last action}{\spath@tempa}%
    \pgfoolet{last action}{\spath@temp}%
    \pgfoolet{first action}{\spath@tempa}%
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.reverse()%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method prepare() {%
    \pgfooget{prepared}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
    \setcounter{spath@reallength}{0}%
    \setcounter{spath@components}{0}%
    \setcounter{spath@length}{0}%
    \spath@prepare@init
    \let\spath@first=\pgfutil@empty
    \pgfoovalueof{path}%
    \edef\spath@temp{\the\value{spath@components}}%
    \pgfoolet{number of components}{\spath@temp}%
    \edef\spath@temp{\the\value{spath@length}}%
    \pgfoolet{length}{\spath@temp}%
    \edef\spath@temp{\the\value{spath@reallength}}%
    \pgfoolet{real length}{\spath@temp}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@sx}{\spath@sy}}%
    \pgfoolet{initial point}{\spath@temp}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@ex}{\spath@ey}}%
    \pgfoolet{final point}{\spath@temp}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
    \pgfoolet{min bb}{\spath@temp}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@max}{\spath@may}}%
    \pgfoolet{max bb}{\spath@temp}%
    \pgfoolet{first action}{\spath@first}%
    \pgfoolet{last action}{\spath@last}%
    \pgfoolet{prepared}{1}%
    \endgroup
    \fi
  }
  \method at least three() {%
    \pgfoothis.prepare()%
    \pgfooget{real length}{\spath@temp}%
    \pgfooget{path}{\spath@tmppath}%
    \ifnum\spath@temp=1\relax
     \pgfooget{first action}{\spath@temp}%
     \ifx\spath@temp\spath@lineto
      \expandafter\spath@split@single@lineto\spath@tmppath\relax
      \pgfoolet{path}{\spath@tmppath}%
      \pgfooset{length}{4}%
     \else
      \expandafter\spath@split@single@curveto\spath@tmppath\relax
      \pgfoolet{path}{\spath@tmppath}%
      \pgfooset{length}{10}%
     \fi
     \pgfooset{real length}{3}%
    \else
     \ifnum\spath@temp=2\relax
      \pgfooget{first action}{\spath@temp}%
      \def\spath@tempa{0}%
      \ifx\spath@temp\spath@lineto
       \expandafter\spath@split@first@lineto\spath@tmppath\relax
       \def\spath@tempa{3}%
      \else
       \expandafter\spath@split@first@curveto\spath@tmppath\relax
       \def\spath@tempa{7}%
      \fi
      \pgfooget{last action}{\spath@temp}%
      \ifx\spath@temp\spath@lineto
       \expandafter\spath@split@second@lineto\spath@split@path@end\relax
       \pgfmathsetmacro{\spath@tempa}{\spath@tempa + 2}
      \else
       \expandafter\spath@split@second@curveto\spath@split@path@end\relax
       \pgfmathsetmacro{\spath@tempa}{\spath@tempa + 6}
      \fi
      \let\spath@tmppath=\spath@split@path@start
      \ge@addto@macro\spath@tmppath\spath@split@path@end
      \pgfoolet{path}{\spath@tmppath}%
      \pgfoolet{length}{\spath@tempa}%
      \pgfooset{real length}{4}%
     \fi
    \fi
  }
  \method taper out() {%
    \pgfoothis.prepare()%
    \pgfooget{first action}{\spath@temp}%
    \pgfooget{path}{\spath@tmppath}%
    \pgfooget{taper line width}{\taper@line@width}%
    \ifx\taper@line@width\pgfutil@empty
     \pgfmathsetmacro{\taper@line@width}{.5*\pgflinewidth}%
    \fi
    \ifx\spath@temp\spath@lineto
     \expandafter\spath@taper@lineto@out\spath@tmppath\relax
    \pgfoolet{path}{\spath@tapered@path}%
    \else
     \ifx\spath@temp\spath@curveto
      \expandafter\spath@taper@curveto@out\spath@tmppath\relax
      \pgfoolet{path}{\spath@tapered@path}%
     \fi
    \fi
  }
  \method split path by length(#1,#2,#3) {%
    \pgfoothis.prepare()%
    \def\spath@test{\the\value{spath@length}}%
    \pgfooget{length}{\spath@length}%
    \pgfoothis.split(#1,#2,#3)%
  }
  \method split path by real length(#1,#2,#3) {%
    \pgfoothis.prepare()%
    \def\spath@test{\the\value{spath@reallength}}%
    \pgfooget{real length}{\spath@length}%
    \pgfoothis.split(#1,#2,#3)%
  }
  \method split path by component(#1,#2,#3) {%
    \pgfoothis.prepare()%
    \def\spath@test{\the\value{spath@components}}%
    \pgfooget{number of components}{\spath@length}%
    \pgfoothis.split(#1,#2,#3)%
  }
  \method split(#1,#2,#3) {%
    \pgfmathsetmacro{\spath@splitat}{#3 < 0 ? \spath@length + #3: #3}%
    \pgfooget{path}{\spath@tmppath}%
    \let\spath@tmppatha=\pgfutil@empty
    \setcounter{spath@length}{0}%
    \setcounter{spath@reallength}{0}%
    \setcounter{spath@components}{-1}%
    \expandafter\spath@gobble\spath@tmppath\relax
    \pgfoonew #1 =new spath(\spath@tmppatha)%
    \pgfoonew #2 =new spath(\spath@tmppath)%
    #1.let(last action,\spath@last)%
    #2.let(first action,\spath@first)%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@ex}{\spath@ey}}%
    #1.let(final point,\spath@temp)%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@sx}{\spath@sy}}%
    #2.let(initial point,\spath@temp)%
    \pgfooget{first action}{\spath@temp}%
    #1.let(first action,\spath@temp)%
    \pgfooget{last action}{\spath@temp}%
    #2.let(last action,\spath@temp)%
    \pgfooget{initial point}{\spath@temp}%
    #1.let(initial point,\spath@temp)%
    \pgfooget{final point}{\spath@temp}%
    #2.let(final point,\spath@temp)%
    #1.let(length,\spath@splitat)%
    \edef\spath@temp{\the\value{spath@reallength}}
    #1.let(real length,\spath@temp)%
    \pgfmathsetmacro{\spath@temp}{\pgfoovalueof{real length} - \spath@temp}
    #2.let(real length,\spath@temp)%
    \edef\spath@temp{\the\value{spath@components}}
    #1.let(number of components,\spath@temp)%
    \pgfmathsetmacro{\spath@temp}{\pgfoovalueof{number of components} - \spath@temp}
    #2.let(number of components,\spath@temp)%
    \pgfooget{taper line width}{\spath@temp}%
    #1.let(taper line width,\spath@temp)%
    #2.let(taper line width,\spath@temp)%
    \pgfmathsetmacro{\spath@splitat}{\spath@length - \spath@splitat}%
    #2.let(length,\spath@splitat)%
    #1.set(prepared,1)%
    #2.set(prepared,1)%
  }
  \method reprocess path() {%
    \begingroup
    \spath@reprocess@init
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}%
    \pgfoovalueof{path}%
    \pgfsyssoftpath@getcurrentpath{\spath@tmppath}%
    \pgfoolet{path}{\spath@tmppath}%
    \endgroup
    \let\spath@tmppath\pgfutil@empty
  }
  \method set as current path() {%
    \pgfooget{path}{\spath@tmppath}%
    \pgfsyssoftpath@setcurrentpath{\spath@tmppath}%
  }
  \method get from current path() {%
    \pgfsyssoftpath@getcurrentpath{\spath@tmppath}%
    \pgfooset{path}{\spath@tmppath}%
    \pgfoothis.set(prepared,0)%
  }
  \method use path(#1) {%
    \pgfooget{path}{\spath@tmppath}%
    \pgfoothis.min bb()%
    \pgf@protocolsizes\pgf@x\pgf@y
    \pgfoothis.max bb()%
    \pgf@protocolsizes\pgf@x\pgf@y
    \pgfsyssoftpath@setcurrentpath{\spath@tmppath}%
    \pgfsyssoftpath@flushcurrentpath
    \pgfusepath{#1}%
  }
  \method use path with tikz(#1) {%
    \path[#1] \pgfextra{%
    \begingroup
    \spath@reprocess@init
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}%
    \pgfoovalueof{path}%
    \endgroup};
  }
  \method to string() {%
     \begingroup
     \spath@string@init
     \pgfoovalueof{path}%
     \endgroup
  }
  \method concatenate(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
     \let\spath@other=#2\relax
     \ifx\spath@other\relax
     \else
      \spath@other.get(path,\spath@tmppath)%
      \pgfooget{path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{path}{\spath@tmppatha}%
      \spath@other.get(final point,\spath@temp)%
      \pgfoolet{final point}{\spath@temp}%
      \spath@other.get(last action,\spath@temp)%
      \pgfoolet{last action}{\spath@temp}%
      \pgfooget{min bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(min bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@mix}{min(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@miy}{min(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{min bb}{\spath@temp}%
      \pgfooget{max bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(max bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@max}{max(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@may}{max(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{max bb}{\spath@temp}%
  \tikz@clear@foreach
      \foreach \attribute in {
        length,
        real length,
        number of components%
      } {
        \spath@other.get(\attribute,\spath@temp)%
        \pgfooget{\attribute}{\spath@tempa}%
        \ifx\spath@temp\pgfutil@empty
        \else
        \ifx\spath@tempa\pgfutil@empty
        \else
         \pgfmathsetmacro{\spath@tempa}{\spath@temp + \spath@tempa}%
         \pgfoolet{\attribute}{\spath@tempa}%
        \fi
        \fi
      }%
    \fi
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.concatenate(,#2)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method concatenate with lineto(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
     \let\spath@other=#2\relax
     \ifx\spath@other\relax
     \else
      \spath@other.get(path,\spath@tmppath)%
      \expandafter\spath@movetoline\spath@tmppath\relax
      \pgfooget{path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{path}{\spath@tmppatha}%
      \spath@other.get(final point,\spath@temp)%
      \pgfoolet{final point}{\spath@temp}%
      \spath@other.get(last action,\spath@temp)%
      \pgfoolet{last action}{\spath@temp}%
      \pgfooget{min bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(min bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@mix}{min(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@miy}{min(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{min bb}{\spath@temp}%
      \pgfooget{max bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(max bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@max}{max(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@may}{max(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{max bb}{\spath@temp}%
  \tikz@clear@foreach
      \foreach \attribute in {
        length,
        real length,
        number of components%
      } {
        \spath@other.get(\attribute,\spath@temp)%
        \pgfooget{\attribute}{\spath@tempa}%
        \ifx\spath@temp\pgfutil@empty
        \else
        \ifx\spath@tempa\pgfutil@empty
        \else
         \pgfmathsetmacro{\spath@tempa}{\spath@temp + \spath@tempa}%
         \pgfoolet{\attribute}{\spath@tempa}%
        \fi
        \fi
      }%
    \fi
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.concatenate with lineto(,#2)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method concatenate without moveto(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
     \let\spath@other=#2\relax
     \ifx\spath@other\relax
     \else
      \spath@other.get(path,\spath@tmppath)%
      \expandafter\spath@trimfirst\spath@tmppath\relax
      \pgfooget{path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{path}{\spath@tmppatha}%
      \spath@other.get(final point,\spath@temp)%
      \pgfoolet{final point}{\spath@temp}%
      \spath@other.get(last action,\spath@temp)%
      \pgfoolet{last action}{\spath@temp}%
      \pgfooget{min bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(min bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@mix}{min(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@miy}{min(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{min bb}{\spath@temp}%
      \pgfooget{max bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(max bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@max}{max(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@may}{max(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{max bb}{\spath@temp}%
  \tikz@clear@foreach
      \foreach \attribute in {
        length,
        real length,
        number of components%
      } {
        \spath@other.get(\attribute,\spath@temp)%
        \pgfooget{\attribute}{\spath@tempa}%
        \ifx\spath@temp\pgfutil@empty
        \else
        \ifx\spath@tempa\pgfutil@empty
        \else
         \pgfmathsetmacro{\spath@tempa}{\spath@temp + \spath@tempa}%
         \pgfoolet{\attribute}{\spath@tempa}%
        \fi
        \fi
      }%
      \pgfooget{length}{\spath@tempa}%
      \pgfmathsetmacro{\spath@tempa}{\spath@tempa - 1}%
      \pgfoolet{length}{\spath@tempa}%
     \fi
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.concatenate without moveto(,#2)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }
  \method weld(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
     \let\spath@other=#2\relax
     \ifx\spath@other\relax
     \else
      \pgfoothis.final point()%
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.initial point()%
      \advance\pgf@xa by -\pgf@x
      \advance\pgf@ya by -\pgf@y
      \spath@other.translate path(\spath@tempo,\the\pgf@xa,\the\pgf@ya)%
      \spath@tempo.get(path,\spath@tmppath)%
      \expandafter\spath@trimfirst\spath@tmppath\relax
      \pgfooget{path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{path}{\spath@tmppatha}%
      \spath@tempo.get(final point,\spath@temp)%
      \pgfoolet{final point}{\spath@temp}%
      \spath@tempo.get(last action,\spath@temp)%
      \pgfoolet{last action}{\spath@temp}%
      \pgfooget{min bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(min bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@mix}{min(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@miy}{min(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{min bb}{\spath@temp}%
      \spath@temp
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.get(max bb,\spath@temp)%
      \spath@temp
      \pgfmathsetmacro{\spath@max}{max(\pgf@x,\pgf@xa)}%
      \pgfmathsetmacro{\spath@may}{max(\pgf@y,\pgf@ya)}%
      \edef\spath@temp{\noexpand\pgfpoint{\spath@mix}{\spath@miy}}%
      \pgfoolet{max bb}{\spath@temp}%
  \tikz@clear@foreach
      \foreach \attribute in {
        length,
        real length,
        number of components%
      } {
        \spath@tempo.get(\attribute,\spath@temp)%
        \pgfooget{\attribute}{\spath@tempa}%
        \ifx\spath@temp\pgfutil@empty
        \else
         \ifx\spath@tempa\pgfutil@empty
         \else
          \pgfmathsetmacro{\spath@tempa}{\spath@temp + \spath@tempa}%
          \pgfoolet{\attribute}{\spath@tempa}%
         \fi
        \fi
      }%
     \fi
    \else
     \pgfoothis.clone(\spath@newpath)%
     \begingroup
      \spath@newpath.weld(,#2)%
     \endgroup
     \let#1=\spath@newpath
    \fi
  }
  \method close() {%
    \pgfooget{path}{\spath@tmppath}%
    \g@addto@macro\spath@tmppath{\pgfsyssoftpath@closepathtoken{0pt}{0pt}}%
    \pgfoolet{path}{\spath@tmppath}%
    \pgfooget{length}{\spath@temp}%
    \pgfmathtruncatemacro{\spath@temp}{\spath@temp + 1}%
    \pgfoolet{length}{\spath@temp}%
    \pgfooget{real length}{\spath@temp}%
    \pgfmathtruncatemacro{\spath@temp}{\spath@temp + 1}%
    \pgfoolet{real length}{\spath@temp}%
    \pgfooget{number of components}{\spath@temp}%
    \pgfmathtruncatemacro{\spath@temp}{\spath@temp + 1}%
    \pgfoolet{number of components}{\spath@temp}%
    \pgfooget{initial point}{\spath@temp}%
    \pgfoolet{final point}{\spath@temp}%
    \pgfooset{last action}{closepath}%
    \pgfooset{prepared}{0}%
  }
  \method split self intersecting pieces() {%
  \begingroup
    \let\spath@tmppath=\pgfutil@empty
    \spath@selfintersect@init
    \pgfoovalueof{path}%
    \pgfoolet{path}{\spath@tmppath}%
  \endgroup
}
  \method explode(#1) {%
  \pgfooget{path}{\spath@tmp}%
  \spathexplode#1\spath@tmp
}
  \method at intersections(#1) {%
  \pgfooget{path}{\spath@tmppath}%
  #1.get(path,\spath@tmppatha)%
  \ifx\spath@tmppatha\pgfutil@empty
  \else
  \pgfoothis.get handle(\spath@firstpath)%
  \let\spath@secondpath=#1%
  \pgfintersectionofpaths{\pgfsetpath\spath@tmppatha}{\pgfsetpath\spath@tmppath}%
  \ifnum\pgfintersectionsolutions>0\relax
  \pgfsyssoftpath@setcurrentpath\pgfutil@empty
  \tikz@clear@foreach
  \foreach \spath@k in {1,...,\pgfintersectionsolutions} {
    \pgfpointintersectionsolution{\spath@k}%
    \edef\spath@ix{\the\pgf@x}%
    \edef\spath@iy{\the\pgf@y}%
    \pgfoothis.initial point()%
    \pgfmathtruncatemacro{\spath@first@nearstart}{(abs(\pgf@x - \spath@ix) + abs(\pgf@y - \spath@iy)) < \spath@intersectiontolerance}%
    \pgfoothis.final point()
    \pgfmathtruncatemacro{\spath@first@nearend}{(abs(\pgf@x - \spath@ix) + abs(\pgf@y - \spath@iy) <  \spath@intersectiontolerance)}%
    \pgfmathtruncatemacro{\spath@first@nearends}{\spath@first@nearstart || \spath@first@nearend}%
    \spath@secondpath.initial point()%
    \pgfmathtruncatemacro{\spath@second@nearstart}{(abs(\pgf@x - \spath@ix) + abs(\pgf@y - \spath@iy)) < \spath@intersectiontolerance}%
    \spath@secondpath.final point()
    \pgfmathtruncatemacro{\spath@second@nearend}{(abs(\pgf@x - \spath@ix) + abs(\pgf@y - \spath@iy) <  \spath@intersectiontolerance)}%
    \pgfmathtruncatemacro{\spath@second@nearends}{\spath@second@nearstart || \spath@second@nearend}%
    \pgfmathtruncatemacro{\spath@nearends}{\spath@first@nearends || \spath@second@nearends}%
    \spath@execute@at@intersections
  }
  \fi
  \fi
}
}
\pgfooclass{spath component}{
  \attribute path;
  \attribute next component;
  \attribute previous component;
  \method spath component(#1) {%
    \def\spath@temp{#1}%
    \ifx\spath@temp\pgfutil@empty
    \else
    \pgfoolet{previous component}{#1}%
    \fi
  }
  \method value(#1) {%
    \pgfoovalueof{#1}%
  }
  \method set(#1,#2) {%
    \pgfooset{#1}{#2}%
  }
  \method let(#1,#2) {%
    \pgfoolet{#1}{#2}%
  }
  \method get(#1,#2) {%
    \pgfooget{#1}{#2}%
  }
  \method show(#1) {%
    \pgfooget{#1}{\@temp}%
    \show\@temp
  }
  \method what am I() {%
     \message{I am an spath component object}%
  }
  \method set path(#1) {%
    \pgfoonew \spath@tempa =new spath(#1)%
    \pgfoolet{path}{\spath@tempa}%
  }
  \method apply to paths(#1,#2) {%
    \pgfooget{path}{\spath@tmppath}%
    \ifx\spath@tmppath\pgfutil@empty
    \else
    \spath@tmppath.#1(#2)%
    \fi
    \pgfooget{next component}{\spath@temp}%
    \let\spath@next=\pgfutil@empty
    \ifx\spath@temp\pgfutil@empty
    \else
     \def\spath@next{\spath@temp.apply to paths(#1,{#2})}%
    \fi
    \spath@next
  }
  \method apply to previous paths(#1,#2) {%
    \pgfooget{path}{\spath@tmppath}%
    \ifx\spath@temppath\pgfutil@empty
    \else
    \spath@tmppath.#1(#2)%
    \fi
    \pgfooget{previous component}{\spath@temp}%
    \let\spath@next=\pgfutil@empty
    \ifx\spath@temp\pgfutil@empty
    \else
     \def\spath@next{\spath@temp.apply to previous paths(#1,{#2})}%
    \fi
    \spath@next%
  }
  \method apply for paths(#1) {%
    #1%
    \pgfooget{next component}{\spath@temp}%
    \let\spath@next=\pgfutil@empty
    \ifx\spath@temp\pgfutil@empty
    \else
     \def\spath@next{\spath@temp.apply for paths({#1})}%
    \fi
    \spath@next%
  }
  \method apply for previous paths(#1) {%
    #1%
    \pgfooget{previous component}{\spath@temp}%
    \let\spath@next=\pgfutil@empty
    \ifx\spath@temp\pgfutil@empty
    \else
     \def\spath@next{\spath@temp.apply for previous paths({#1})}%
    \fi
    \spath@next%
  }
  \method at intersections(#1,#2,#3) {%
  \let\spath@next=\pgfutil@empty
  \let\spath@tmp#1\relax%
  \let\spath@secondpath@prev#2\relax
  \let\spath@secondpath@next#3\relax
  \ifx\spath@tmp\relax
   \pgfooget{path}{\spath@tmp}%
   \pgfooget{previous component}{\spath@temp}%
   \ifx\spath@temp\pgfutil@empty
   \else
   \spath@temp.get(path,\spath@secondpath@prev)%
   \fi
   \pgfooget{next component}{\spath@temp}%
   \ifx\spath@temp\pgfutil@empty
   \else
    \spath@temp.get(path,\spath@secondpath@next)%
    \def\spath@next{%
     \begingroup
     \spath@temp.at intersections(\spath@tmp,\spath@secondpath@prev,\spath@secondpath@next)%
     \endgroup
     \spath@temp.at intersections(,,)%
    }
   \fi
  \else
   \begingroup
    \pgfooget{previous component}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \else
     \spath@temp.get(path,\spath@firstpath@prev)%
    \fi
    \pgfooget{next component}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \else
     \spath@temp.get(path,\spath@firstpath@next)%
    \fi
    \pgfooget{path}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \else
     \spath@temp.at intersections(\spath@tmp)%
    \fi
   \endgroup
   \pgfooget{next component}{\spath@temp}%
   \ifx\spath@temp\pgfutil@empty
   \else
    \def\spath@next{%
     \spath@temp.at intersections(\spath@tmp,\spath@secondpath@prev,\spath@secondpath@next)%
    }
   \fi
  \fi
  \spath@next
  }
}
\def\spathsplit#1#2{%
  \ifx#1\relax
  \pgfoonew #1 =new spath component({})%
  \else
  \message{\string#1\space already defined}
  \fi
  \let\spath@this@component=#1\relax
  \expandafter\spath@split@#2\relax
}
\def\spath@split@\pgfsyssoftpath@movetotoken#1\relax{%
  \spath@split@@#1\pgfsyssoftpath@movetotoken\relax
}
\def\spath@split@@#1\pgfsyssoftpath@movetotoken#2\relax{%
  \def\spath@tmppath{\pgfsyssoftpath@movetotoken#1}%
  \spath@this@component.set path(\spath@tmppath)%
  \def\spath@tmppath{#2}%
  \ifx\spath@tmppath\pgfutil@empty
  \else
   \pgfoonew \spath@next@component =new spath component(\spath@this@component)%
   \spath@this@component.let(next component,\spath@next@component)%
   \let\spath@this@component=\spath@next@component
   \spath@split@@#2\relax
  \fi
}
\def\spathexplode#1#2{%
  \ifdefined#1
  \else
  \pgfoonew #1 =new spath component({})%
  \fi
  \let\spath@this@component=#1\relax
  \expandafter\spath@explode@#2\relax
}
\def\spath@explode@#1{%
  \let\spath@explode@next=\pgfutil@empty
  \ifx#1\pgfsyssoftpath@movetotoken
  \let\spath@explode@next=\spath@explode@savexy
  \else
  \ifx#1\pgfsyssoftpath@linetotoken
  \let\spath@explode@next=\spath@explode@lineto
  \else
  \ifx#1\pgfsyssoftpath@curvetosupportatoken
  \let\spath@explode@next=\spath@explode@curveto
  \else
  \ifx#1\pgfsyssoftpath@closepathtoken
  \let\spath@explode@next=\spath@explode@lineto
  \else
  \ifx#1\pgfsyssoftpath@recttoken
  \let\spath@explode@next=\spath@explode@rect
  \fi
  \fi
  \fi
  \fi
  \fi
  \spath@explode@next
}
\def\spath@explode@savexy#1#2{%
  \def\spath@ex{#1}%
  \def\spath@ey{#2}%
  \spath@explode@%
}
\def\spath@explode@lineto#1#2{%
  \edef\spath@tmppath{\noexpand\pgfsyssoftpath@movetotoken{\spath@ex}{\spath@ey}\noexpand\pgfsyssoftpath@linetotoken{#1}{#2}}%
  \spath@this@component.set path(\spath@tmppath)%
  \pgfoonew \spath@next@component =new spath component(\spath@this@component)%
  \spath@this@component.let(next component,\spath@next@component)%
  \let\spath@this@component=\spath@next@component
  \def\spath@ex{#1}%
  \def\spath@ey{#2}%
  \spath@explode@%
}
\def\spath@explode@curveto#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
  \edef\spath@tmppath{\noexpand\pgfsyssoftpath@movetotoken{\spath@ex}{\spath@ey}\noexpand\pgfsyssoftpath@curvetosupportatoken{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportbtoken{#3}{#4}\noexpand\pgfsyssoftpath@curvetotoken{#5}{#6}}%
  \spath@this@component.set path(\spath@tmppath)%
  \pgfoonew \spath@next@component =new spath component(\spath@this@component)%
  \spath@this@component.let(next component,\spath@next@component)%
  \let\spath@this@component=\spath@next@component
  \def\spath@ex{#5}%
  \def\spath@ey{#6}%
  \spath@explode@%
}
\def\spath@define@translate#1\relax{%
  \expandafter\gdef\csname spath@tr@#1\endcsname##1##2{%
    \pgf@xa=##1\relax
    \pgf@ya=##2\relax
    \advance\pgf@xa by \spath@trx
    \advance\pgf@ya by \spath@try
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{\the\pgf@xa}{\the\pgf@ya}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@transform#1\relax{%
  \expandafter\gdef\csname spath@trans@#1\endcsname##1##2{%
    \pgf@xa=##1\relax
    \pgf@ya=##2\relax
    \pgf@process{\pgfpointtransformed{\pgfqpoint{\pgf@xa}{\pgf@ya}}}%
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{\the\pgf@x}{\the\pgf@y}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@scale#1\relax{%
  \expandafter\gdef\csname spath@sc@#1\endcsname##1##2{%
    \pgf@xa=##1\relax
    \pgf@ya=##2\relax
    \pgf@xa=\spath@scx\pgf@xa\relax
    \pgf@ya=\spath@scy\pgf@ya\relax
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{\the\pgf@xa}{\the\pgf@ya}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@round#1\relax{%
  \expandafter\gdef\csname spath@rnd@#1\endcsname##1##2{%
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{##1}{##2}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@shrink#1\relax{%
  \expandafter\gdef\csname spath@sh@#1\endcsname##1##2{%
    \pgfmathsetlength{\pgf@xa}{##1 < \spath@trx ? ##1 + \spath@shrinkby : (##1 > \spath@trx ? ##1 - \spath@shrinkby : ##1)}%
    \pgfmathsetlength{\pgf@ya}{##2 < \spath@try ? ##2 + \spath@shrinkby : (##2 > \spath@try ? ##2 - \spath@shrinkby : ##2)}%
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{\the\pgf@xa}{\the\pgf@ya}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@spirograph#1\relax{%
  \expandafter\gdef\csname spath@gch@#1\endcsname##1##2{%
    \pgf@xa=##1\relax
    \pgf@ya=##2\relax
    \advance\pgf@xa by -\spath@trx
    \advance\pgf@ya by -\spath@try
    \pgfmathsetmacro\spath@gcos{cos(\spath@n * \spath@gang)}
    \pgfmathsetmacro\spath@gsin{sin(\spath@n * \spath@gang)}
    \pgfmathsetmacro\spath@n{\spath@n + 1}%
    \global\let\spath@n=\spath@n
    \pgfmathsetlength\pgf@xb{\spath@gcos * \pgf@xa - \spath@gsin * \pgf@ya}
    \pgfmathsetlength\pgf@yb{\spath@gsin * \pgf@xa + \spath@gcos * \pgf@ya}
    \advance\pgf@xb by \spath@trx
    \advance\pgf@yb by \spath@try
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{\the\pgf@xb}{\the\pgf@yb}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@rotate#1\relax{%
  \expandafter\gdef\csname spath@rot@#1\endcsname##1##2{%
    \pgf@xa=##1\relax
    \pgf@ya=##2\relax
    \pgfmathsetlength\pgf@xb{\spath@gcos * \pgf@xa - \spath@gsin * \pgf@ya}
    \pgfmathsetlength\pgf@yb{\spath@gsin * \pgf@xa + \spath@gcos * \pgf@ya}
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{\the\pgf@xb}{\the\pgf@yb}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@length#1\relax{%
  \expandafter\gdef\csname spath@len@#1\endcsname##1##2{%
    \stepcounter{spath@length}
  }
}
\def\spath@define@components#1\relax{%
  \expandafter\gdef\csname spath@comp@#1\endcsname##1##2{%
  }
}
\def\spath@define@reallength#1\relax{%
  \expandafter\gdef\csname spath@rlen@#1\endcsname##1##2{%
  }
}
\def\spath@define@reverse#1\relax{%
  \expandafter\gdef\csname spath@rev@#1\endcsname##1##2{%
    \edef\spath@tmp{{##1}{##2}\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname}
    \ge@addbefore@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@start#1\relax{%
  \expandafter\gdef\csname spath@start@#1\endcsname##1##2{%
    \edef\spath@sx{##1}
    \edef\spath@sy{##2}
    \spath@start@reinit
  }
}
\def\spath@define@end#1\relax{%
  \expandafter\gdef\csname spath@end@#1\endcsname##1##2{%
    \edef\spath@ex{##1}
    \edef\spath@ey{##2}
  }
}
\def\spath@define@array#1\relax{%
  \expandafter\gdef\csname spath@array@#1\endcsname##1##2{%
    \edef\spath@tmp{\expandafter\noexpand\csname       pgfsyssoftpath@#1token\endcsname{##1}{##2}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@reprocess#1\relax{%
  \expandafter\gdef\csname spath@rep@#1\endcsname##1##2{%
    \csname pgfpath#1\endcsname{\pgfpoint{##1}{##2}}%
  }%
}
\def\spath@define@selfintersect#1{%
  \expandafter\gdef\csname spath@selfintersect@#1\endcsname##1##2{%
    \edef\spath@ex{##1}%
    \edef\spath@ey{##2}%
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{##1}{##2}}%
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}
\def\spath@define@boundingbox#1{%
  \expandafter\gdef\csname spath@boundingbox@#1\endcsname##1##2{%
     \pgfmathsetmacro\spath@mix{min(\spath@mix,##1)}%
     \pgfmathsetmacro\spath@miy{min(\spath@miy,##2)}%
     \pgfmathsetmacro\spath@max{max(\spath@max,##1)}%
     \pgfmathsetmacro\spath@may{max(\spath@may,##2)}%
  }%
}%
\def\spath@define@string#1\relax{%
  \expandafter\gdef\csname spath@str@#1\endcsname##1##2{%
  \pgfmathsetmacro\spath@sx{##1/1cm}%
  \pgfmathsetmacro\spath@sy{##2/1cm}%
    \expandafter\string\csname pgfpath#1\endcsname\{\string\pgfpointxy\{\spath@sx\}\{\spath@sy\}\}\\%
  }%
}
\let\spath@spirograph@init=\pgfutil@empty
\let\spath@rotate@init=\pgfutil@empty
\let\spath@round@init=\pgfutil@empty
\let\spath@translate@init=\pgfutil@empty
\let\spath@transform@init=\pgfutil@empty
\let\spath@scale@init=\pgfutil@empty
\let\spath@shrink@init=\pgfutil@empty
\let\spath@length@init=\pgfutil@empty
\let\spath@components@init=\pgfutil@empty
\let\spath@reallength@init=\pgfutil@empty
\let\spath@reverse@init=\pgfutil@empty
\let\spath@start@init=\pgfutil@empty
\let\spath@start@reinit=\pgfutil@empty
\let\spath@end@init=\pgfutil@empty
\let\spath@array@init=\pgfutil@empty
\let\spath@prepare@init=\pgfutil@empty
\let\spath@reprocess@init=\pgfutil@empty
\let\spath@string@init=\pgfutil@empty
\let\spath@selfintersect@init=\pgfutil@empty
\def\spath@boundingbox@init{%
  \def\spath@mix{16000pt}%
  \def\spath@miy{16000pt}%
  \def\spath@max{-16000pt}%
  \def\spath@may{-16000pt}%
}
  \tikz@clear@foreach
\foreach \spath@cpt in {
  moveto,
  lineto,
  curvetosupporta,
  curvetosupportb,
  curveto,
  rectcorner,
  rectsize,
  closepath,
  specialround%
} {
\expandafter\xdef\csname spath@\spath@cpt\endcsname{\expandafter\string\csname pgfsyssoftpath@\spath@cpt token\endcsname}
\expandafter\spath@define@translate\spath@cpt\relax
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@tr@\spath@cpt \endcsname}

\ge@addto@macro\spath@translate@init\spath@tmp
\expandafter\spath@define@transform\spath@cpt\relax
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@trans@\spath@cpt \endcsname}

\ge@addto@macro\spath@transform@init\spath@tmp
\expandafter\spath@define@scale\spath@cpt\relax
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@sc@\spath@cpt \endcsname}

\ge@addto@macro\spath@scale@init\spath@tmp
\expandafter\spath@define@round\spath@cpt\relax
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@rnd@\spath@cpt \endcsname}

\ge@addto@macro\spath@round@init\spath@tmp
\expandafter\spath@define@shrink\spath@cpt\relax
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@sh@\spath@cpt \endcsname}

\ge@addto@macro\spath@shrink@init\spath@tmp
\expandafter\spath@define@spirograph\spath@cpt\relax
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@gch@\spath@cpt \endcsname}

\ge@addto@macro\spath@spirograph@init\spath@tmp
\expandafter\spath@define@rotate\spath@cpt\relax
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@rot@\spath@cpt \endcsname}

\ge@addto@macro\spath@rotate@init\spath@tmp
\expandafter\spath@define@length\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@len@\spath@cpt \endcsname}

\ge@addto@macro\spath@length@init\spath@tmp
\expandafter\spath@define@components\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@comp@\spath@cpt \endcsname}

\ge@addto@macro\spath@components@init\spath@tmp
\expandafter\spath@define@reallength\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@rlen@\spath@cpt \endcsname}

\ge@addto@macro\spath@reallength@init\spath@tmp
\expandafter\spath@define@reverse\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@rev@\spath@cpt \endcsname}

\ge@addto@macro\spath@reverse@init\spath@tmp
\expandafter\spath@define@start\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@start@\spath@cpt \endcsname}

\ge@addto@macro\spath@start@init\spath@tmp
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\noexpand\@gobbletwo}

\ge@addto@macro\spath@start@reinit\spath@tmp
\expandafter\spath@define@end\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@end@\spath@cpt \endcsname}

\ge@addto@macro\spath@end@init\spath@tmp
\expandafter\spath@define@array\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@array@\spath@cpt \endcsname}

\ge@addto@macro\spath@array@init\spath@tmp
\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@prepare@\spath@cpt \endcsname}

\ge@addto@macro\spath@prepare@init\spath@tmp
\expandafter\spath@define@reprocess\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@rep@\spath@cpt \endcsname}

\ge@addto@macro\spath@reprocess@init\spath@tmp
\expandafter\spath@define@selfintersect\expandafter{\spath@cpt}

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@selfintersect@\spath@cpt \endcsname}

\ge@addto@macro\spath@selfintersect@init\spath@tmp
\expandafter\spath@define@boundingbox\expandafter{\spath@cpt}

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@boundingbox@\spath@cpt \endcsname}

\ge@addto@macro\spath@boundingbox@init\spath@tmp
\expandafter\spath@define@string\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cpt token\endcsname=\expandafter\noexpand\csname spath@str@\spath@cpt \endcsname}

\ge@addto@macro\spath@string@init\spath@tmp
}
\def\spath@comp@moveto#1#2{%
  \stepcounter{spath@length}%
}
\def\spath@rlen@lineto#1#2{%
  \stepcounter{spath@length}%
}
\def\spath@rlen@curveto#1#2{%
  \stepcounter{spath@length}%
}
\def\spath@rev@moveto#1#2{
  \ifx\spath@tmppath\pgfutil@empty
  \edef\spath@tmp{{#1}{#2}}%
  \else
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@movetotoken}%
  \fi
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}
\def\spath@rev@curvetosupporta#1#2{%
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@curvetotoken}%
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}
\def\spath@rev@curvetosupportb#1#2{%
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportbtoken}%
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}
\def\spath@rev@curveto#1#2{%
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportatoken}%
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}
\def\spath@rev@closepath#1#2{%
  \edef\spath@tmp{\noexpand\pgfsyssoftpath@closepathtoken{#1}{#2}}%
  \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@rep@curvetosupporta#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
    \pgfpathcurveto{\pgfpoint{#1}{#2}}{\pgfpoint{#3}{#4}}{\pgfpoint{#5}{#6}}%
  }%
\def\spath@str@curvetosupporta#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
  \pgfmathsetmacro\spath@sx{#1/1cm}%
  \pgfmathsetmacro\spath@sy{#2/1cm}%
    \string\pgfpathcurveto\{\string\pgfpointxy\{\spath@sx\}\{\spath@sy\}\}%
  \pgfmathsetmacro\spath@sx{#3/1cm}%
  \pgfmathsetmacro\spath@sy{#4/1cm}%
  \{\string\pgfpointxy\{\spath@sx\}\{\spath@sy\}\}%
  \pgfmathsetmacro\spath@sx{#5/1cm}%
  \pgfmathsetmacro\spath@sy{#6/1cm}%
  \{\string\pgfpointxy\{\spath@sx\}\{\spath@sy\}\}\\%
  }%
\def\spath@str@closepath#1#2{%
  \string\pgfclosepath\\}
\def\spath@array@moveto#1#2{%
  \ifx\spath@tmppath\pgfutil@empty
  \else
   \expandafter\global\expandafter\let\csname spath@array@\spath@path@name @\the\value{spath@array}\endcsname=\spath@tmppath
   \def\spath@tmppath{\pgfsyssoftpath@movetotoken{#1}{#2}}%
  \fi
  \stepcounter{spath@array}%
}
\def\spath@rnd@lineto#1#2{%
  \edef\spath@tmp{%
    \noexpand\pgfsyssoftpath@specialroundtoken{\spath@rndx}{\spath@rndy}%
    \noexpand\pgfsyssoftpath@linetotoken{#1}{#2}}%
    \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@rnd@closepath#1#2{%
  \edef\spath@tmp{%
    \noexpand\pgfsyssoftpath@specialroundtoken{\spath@rndx}{\spath@rndy}%
    \noexpand\pgfsyssoftpath@closepathtoken{#1}{#2}}%
    \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@rnd@curvetosupportatoken#1#2{%
  \edef\spath@tmp{%
    \noexpand\pgfsyssoftpath@specialroundtoken{\spath@rndx}{\spath@rndy}%
    \noexpand\pgfsyssoftpath@curvetosupportatoken{#1}{#2}}%
    \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@rnd@specialround#1#2#3#4#5{%
  \pgfmathsetmacro{\spath@srndx}{max(#1,\spath@rndx)}%
  \pgfmathsetmacro{\spath@srndy}{max(#1,\spath@rndy)}%
  \edef\spath@tmp{%
    \noexpand\pgfsyssoftpath@specialroundtoken{\spath@srndx pt}{\spath@srndy pt}%
    \noexpand#3{#4}{#5}}%
    \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@tr@specialround#1#2{%
  \edef\spath@tmp{\noexpand\pgfsyssoftpath@specialroundtoken{#1}{#2}}%
  \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@rev@specialround#1#2{%
  \edef\spath@tmp{\noexpand\pgfsyssoftpath@specialroundtoken{#1}{#2}}%
  \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@sh@specialround#1#2{%
  \edef\spath@tmp{\noexpand\pgfsyssoftpath@specialroundtoken{#1}{#2}}%
  \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@rot@specialround#1#2{%
  \edef\spath@tmp{\noexpand\pgfsyssoftpath@specialroundtoken{#1}{#2}}%
  \ge@addto@macro\spath@tmppath\spath@tmp
}
\def\spath@prepare@moveto#1#2{%
  \ifx\spath@tmppath\pgfutil@empty
  \g@addbefore@macro\spath@tmppath{{#1}{#2}}%
  \edef\spath@sx{#1}%
  \edef\spath@sy{#2}%
  \edef\spath@mix{#1}%
  \edef\spath@miy{#2}%
  \edef\spath@max{#1}%
  \edef\spath@may{#2}%
  \else
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@movetotoken}%
  \pgfmathsetmacro{\spath@mix}{min(\spath@mix,#1)}%
  \pgfmathsetmacro{\spath@max}{max(\spath@max,#1)}%
  \pgfmathsetmacro{\spath@miy}{min(\spath@miy,#2)}%
  \pgfmathsetmacro{\spath@may}{max(\spath@may,#2)}%
  \fi
  \edef\spath@ex{#1}%
  \edef\spath@ey{#2}%
  \stepcounter{spath@length}%
  \stepcounter{spath@components}%
  \let\spath@last\spath@moveto
}

\def\spath@prepare@lineto#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@linetotoken}%
  \edef\spath@ex{#1}%
  \edef\spath@ey{#2}%
  \pgfmathsetmacro{\spath@mix}{min(\spath@mix,#1)}%
  \pgfmathsetmacro{\spath@max}{max(\spath@max,#1)}%
  \pgfmathsetmacro{\spath@miy}{min(\spath@miy,#2)}%
  \pgfmathsetmacro{\spath@may}{max(\spath@may,#2)}%
  \stepcounter{spath@length}%
  \stepcounter{spath@reallength}%
  \let\spath@last\spath@lineto
  \ifx\spath@first\pgfutil@empty
  \let\spath@first\spath@lineto
  \fi
}

\def\spath@prepare@curveto#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@curvetosupportatoken}%
  \edef\spath@ex{#1}%
  \edef\spath@ey{#2}%
  \pgfmathsetmacro{\spath@mix}{min(\spath@mix,#1)}%
  \pgfmathsetmacro{\spath@max}{max(\spath@max,#1)}%
  \pgfmathsetmacro{\spath@miy}{min(\spath@miy,#2)}%
  \pgfmathsetmacro{\spath@may}{max(\spath@may,#2)}%
  \stepcounter{spath@length}%
  \stepcounter{spath@reallength}%
  \let\spath@last\spath@curveto
  \ifx\spath@first\pgfutil@empty
  \let\spath@first\spath@curveto
  \fi
}

\def\spath@prepare@curvetosupporta#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@curvetotoken}%
  \stepcounter{spath@length}%
  \pgfmathsetmacro{\spath@mix}{min(\spath@mix,#1)}%
  \pgfmathsetmacro{\spath@max}{max(\spath@max,#1)}%
  \pgfmathsetmacro{\spath@miy}{min(\spath@miy,#2)}%
  \pgfmathsetmacro{\spath@may}{max(\spath@may,#2)}%
}

\def\spath@prepare@curvetosupportb#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@curvetosupportbtoken}%
  \stepcounter{spath@length}%
  \pgfmathsetmacro{\spath@mix}{min(\spath@mix,#1)}%
  \pgfmathsetmacro{\spath@max}{max(\spath@max,#1)}%
  \pgfmathsetmacro{\spath@miy}{min(\spath@miy,#2)}%
  \pgfmathsetmacro{\spath@may}{max(\spath@may,#2)}%
}

\def\spath@prepare@closepath#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@closepathtoken}%
  \stepcounter{spath@length}%
}

\def\spath@prepare@specialround#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@specialroundtoken}%
  \stepcounter{spath@length}%
}
\def\spath@selfintersect@curvetosupporta#1#2\pgfsyssoftpath@curvetosupportbtoken#3#4\pgfsyssoftpath@curvetotoken#5#6{%
  \pgfmathsetmacro{\spath@ax}{\spath@ex/28}
  \pgfmathsetmacro{\spath@bx}{#1/28}
  \pgfmathsetmacro{\spath@cx}{#3/28}
  \pgfmathsetmacro{\spath@dx}{#5/28}
  \pgfmathsetmacro{\spath@ay}{\spath@ey/28}
  \pgfmathsetmacro{\spath@by}{#2/28}
  \pgfmathsetmacro{\spath@cy}{#4/28}
  \pgfmathsetmacro{\spath@dy}{#6/28}
  \pgfmathsetmacro{\spath@enum}{%
    ( (\spath@ay - 3 * \spath@by + 3 * \spath@cy - \spath@dy) * (3 *
\spath@cx - 3 * \spath@dx)
    - (\spath@ax - 3 * \spath@bx + 3 * \spath@cx - \spath@dx) * (3 *
\spath@cy - 3 * \spath@dy) )}
  \pgfmathsetmacro{\spath@denum}{%
    ( (\spath@ax - 3 * \spath@bx + 3 * \spath@cx - \spath@dx) * (3 *
\spath@by - 6 * \spath@cy + 3 * \spath@dy)
    - (\spath@ay - 3 * \spath@by + 3 * \spath@cy - \spath@dy) * (3 *
\spath@bx - 6 * \spath@cx + 3 * \spath@dx) )}
  \pgfmathtruncatemacro{\spath@split}{\spath@enum > 0 ? (\spath@enum <
2 * \spath@denum) : (\spath@enum > 2 * \spath@denum)}
  \ifnum\spath@split=1\relax
  \pgfmathsetmacro{\spath@splitt}{.5*(\spath@enum)/(\spath@denum)}%
  \pgfsyssoftpath@setcurrentpath{\spath@tmppath}%
  \pgfpathcurvebetweentimecontinue{0}{\spath@splitt}{\pgfqpoint{\spath@ex}{\spath@ey}}{\pgfqpoint{#1}{#2}}{\pgfqpoint{#3}{#4}}{\pgfqpoint{#5}{#6}}%
  \pgfpathcurvebetweentimecontinue{\spath@splitt}{1}{\pgfqpoint{\spath@ex}{\spath@ey}}{\pgfqpoint{#1}{#2}}{\pgfqpoint{#3}{#4}}{\pgfqpoint{#5}{#6}}%
  \pgfsyssoftpath@getcurrentpath{\spath@tmppath}%
  \else
    \g@addto@macro\spath@tmppath{%
    \pgfsyssoftpath@curvetosupportatoken{#1}{#2}%
    \pgfsyssoftpath@curvetosupportbtoken{#3}{#4}%
    \pgfsyssoftpath@curvetotoken{#5}{#6}%
  }%
  \fi
  \edef\spath@ex{#5}%
  \edef\spath@ey{#6}%
}
\def\spath@trimfirst#1#2#3#4\relax{%
  \edef\spath@this@action{\string#1}%
  \ifx\spath@this@action\spath@moveto
   \def\spath@tmppath{#4}%
  \else
   \def\spath@tmppath{#1{#2}{#3}#4}%
  \fi
}
\def\spath@movetoline#1#2#3#4\relax{%
  \edef\spath@this@action{\string#1}%
  \ifx\spath@this@action\spath@moveto
   \def\spath@tmppath{\pgfsyssoftpath@linetotoken{#2}{#3}#4}%
  \else
   \def\spath@tmppath{#1{#2}{#3}#4}%
  \fi
}
\def\spath@gobble#1#2#3{%
  \stepcounter{spath@length}%
  \edef\spath@this@action{\string#1}%
  \ifx\spath@this@action\spath@lineto
   \stepcounter{spath@reallength}%
  \fi
  \ifx\spath@this@action\spath@curveto
   \stepcounter{spath@reallength}%
  \fi
  \ifx\spath@this@action\spath@moveto
   \stepcounter{spath@components}%
  \fi
  \g@addto@macro\spath@tmppatha{#1{#2}{#3}}%
  \ifnum\spath@test=\spath@splitat\relax
   \def\spath@tmppath{\pgfsyssoftpath@movetotoken{#2}{#3}}%
   \edef\spath@last{\string#1}%
   \ifx\spath@last\spath@curvetosupporta
    \let\spath@last=\spath@curveto
   \fi
   \edef\spath@ex{#2}%
   \edef\spath@ey{#3}%
   \let\spath@next=\spath@lastgobble
  \else
   \let\spath@next=\spath@gobble
  \fi
  \pgfutil@ifnextchar\relax{%
    \ifx\spath@next\spath@gobble
     \def\spath@tmppath{\pgfsyssoftpath@movetotoken{#2}{#3}}%
     \edef\spath@last{\string#1}%
     \ifx\spath@last\spath@curvetosupporta
      \let\spath@last=\spath@curveto
     \fi
     \edef\spath@ex{#2}%
     \edef\spath@ey{#3}%
    \fi
    \edef\spath@sx{#2}%
    \edef\spath@sy{#3}%
    \let\spath@first\spath@moveto
    }{\spath@next}%
}
\def\spath@lastgobble#1#2#3#4\relax{%
  \g@addto@macro\spath@tmppath{#1{#2}{#3}#4}%
   \edef\spath@first{\string#1}%
  \ifx\spath@first\spath@curvetosupporta
  \let\spath@first=\spath@curveto
  \fi
   \edef\spath@sx{#2}%
   \edef\spath@sy{#3}%
}
\newdimen\spath@trx
\newdimen\spath@try
\newcounter{spath@length}
\newcounter{spath@reallength}
\newcounter{spath@components}
\newcounter{spath@array}
\def\spath@taper@lineto@out#1#2#3#4#5#6#7\relax{%
  \pgfmathsetmacro{\spath@sx}{.7 * #2 + .3 * #5}
  \pgfmathsetmacro{\spath@sy}{.7 * #3 + .3 * #6}
  \pgfmathsetmacro{\spath@ex}{.3 * #2 + .7 * #5}
  \pgfmathsetmacro{\spath@ey}{.3 * #3 + .7 * #6}
  \edef\spath@tmp{\noexpand\spath@taper@path{#2}{#3}{\spath@sx pt}{\spath@sy pt}{\spath@ex pt}{\spath@ey pt}{#5}{#6}}
  \spath@tmp
}
\def\spath@taper@curveto@out\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \spath@taper@path{#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
}
\def\spath@taper@path#1#2#3#4#5#6#7#8{
  \edef\spath@sx{#1}
  \edef\spath@sy{#2}
  \edef\spath@cx{#3}
  \edef\spath@cy{#4}
  \edef\spath@dx{#5}
  \edef\spath@dy{#6}
  \edef\spath@ex{#7}
  \edef\spath@ey{#8}

  \pgfmathsetmacro{\spath@ox}{-\spath@ey + \spath@dy}
  \pgfmathsetmacro{\spath@oy}{\spath@ex - \spath@dx}

  \pgfmathsetmacro{\spath@sox}{\spath@sy - \spath@cy}
  \pgfmathsetmacro{\spath@soy}{-\spath@sx + \spath@cx}

  \pgfmathsetmacro{\spath@oox}{.5*\spath@ox * \pgflinewidth / veclen(\spath@ox,\spath@oy)}
  \pgfmathsetmacro{\spath@ooy}{.5*\spath@oy * \pgflinewidth / veclen(\spath@ox,\spath@oy)}

  \pgfmathsetmacro{\spath@soox}{.5*\spath@sox * \taper@line@width / veclen(\spath@sox,\spath@soy)}
  \pgfmathsetmacro{\spath@sooy}{.5*\spath@soy * \taper@line@width / veclen(\spath@sox,\spath@soy)}
  \pgfmathsetmacro{\spath@sx}{\spath@sx + \spath@soox}
  \pgfmathsetmacro{\spath@sy}{\spath@sy + \spath@sooy}
  \pgfmathsetmacro{\spath@cx}{\spath@cx + \spath@soox}
  \pgfmathsetmacro{\spath@cy}{\spath@cy + \spath@sooy}
  \pgfmathsetmacro{\spath@dx}{\spath@dx + \spath@oox}
  \pgfmathsetmacro{\spath@dy}{\spath@dy + \spath@ooy}
  \pgfmathsetmacro{\spath@ex}{\spath@ex + \spath@oox}
  \pgfmathsetmacro{\spath@ey}{\spath@ey + \spath@ooy}
  \let\spath@tapered@path=\pgfutil@empty
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@movetotoken{\spath@sx pt}{\spath@sy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx pt}{\spath@cy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \pgfmathsetmacro{\spath@fx}{\spath@ex + 1.32*\spath@ooy}
  \pgfmathsetmacro{\spath@fy}{\spath@ey - 1.32*\spath@oox}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \pgfmathsetmacro{\spath@fx}{\spath@fx - 2*\spath@oox}
  \pgfmathsetmacro{\spath@fy}{\spath@fy - 2*\spath@ooy}
  \pgfmathsetmacro{\spath@dx}{\spath@dx - 2*\spath@oox}
  \pgfmathsetmacro{\spath@dy}{\spath@dy - 2*\spath@ooy}
  \pgfmathsetmacro{\spath@ex}{\spath@ex - 2*\spath@oox}
  \pgfmathsetmacro{\spath@ey}{\spath@ey - 2*\spath@ooy}
  \pgfmathsetmacro{\spath@cx}{\spath@cx - 2*\spath@soox}
  \pgfmathsetmacro{\spath@cy}{\spath@cy - 2*\spath@sooy}
  \pgfmathsetmacro{\spath@sx}{\spath@sx - 2*\spath@soox}
  \pgfmathsetmacro{\spath@sy}{\spath@sy - 2*\spath@sooy}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@dx pt}{\spath@dy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@cx pt}{\spath@cy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@sx pt}{\spath@sy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \pgfmathsetmacro{\spath@fx}{\spath@sx - 1.32*\spath@sooy}
  \pgfmathsetmacro{\spath@fy}{\spath@sy + 1.32*\spath@soox}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \pgfmathsetmacro{\spath@fx}{\spath@fx + 2*\spath@soox}
  \pgfmathsetmacro{\spath@fy}{\spath@fy + 2*\spath@sooy}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \pgfmathsetmacro{\spath@sx}{\spath@sx + 2*\spath@soox}
  \pgfmathsetmacro{\spath@sy}{\spath@sy + 2*\spath@sooy}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@sx pt}{\spath@sy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
}
\def\spath@single@split{.3}
\def\spath@split@single@lineto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@linetotoken#3#4#5\relax{%
  \pgfmathsetmacro{\spath@sx}{(1-\spath@single@split)*#1 + \spath@single@split * #3}
  \pgfmathsetmacro{\spath@sy}{(1-\spath@single@split)*#2 + \spath@single@split * #4}
  \pgfmathsetmacro{\spath@ex}{(1-\spath@single@split)*#3 + \spath@single@split * #1}
  \pgfmathsetmacro{\spath@ey}{(1-\spath@single@split)*#4 + \spath@single@split * #2}
  \edef\spath@tmppath{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@linetotoken{\spath@sx     pt}{\spath@sy pt}\noexpand\pgfsyssoftpath@linetotoken{\spath@ex pt}{\spath@ey pt}\noexpand\pgfsyssoftpath@linetotoken{#3}{#4}}
}
\def\spath@split@single@curveto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@single@split)*#1 + \spath@single@split * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@single@split)*#2 + \spath@single@split * #4}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@single@split)^2 * #1 + 2*\spath@single@split * (1 - \spath@single@split) * #3 + \spath@single@split^2 * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@single@split)^2 * #2 + 2*\spath@single@split * (1 - \spath@single@split) * #4 + \spath@single@split^2 * #6}
  \pgfmathsetmacro{\spath@ex}{(1 - \spath@single@split)^3 * #1 + 3*\spath@single@split * (1 - \spath@single@split)^2 * #3 + 3*\spath@single@split^2 * (1 - \spath@single@split) * #5 + \spath@single@split^3 * #7}
  \pgfmathsetmacro{\spath@ey}{(1 - \spath@single@split)^3 * #2 + 3*\spath@single@split * (1 - \spath@single@split)^2 * #4 + 3*\spath@single@split^2 * (1 - \spath@single@split) * #6 + \spath@single@split^3 * #8}
  \edef\spath@tmppath{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@single@split)^2*\spath@single@split * #1 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #3 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #5 + \spath@single@split^2 * (1 - \spath@single@split) * #7}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@single@split)^2*\spath@single@split * #2 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #4 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #6 + \spath@single@split^2 * (1 - \spath@single@split) * #8}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@single@split)^2*\spath@single@split * #7 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #5 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #3 + \spath@single@split^2 * (1 - \spath@single@split) * #1}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@single@split)^2*\spath@single@split * #8 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #6 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #4 + \spath@single@split^2 * (1 - \spath@single@split) * #2}
  \pgfmathsetmacro{\spath@ex}{\spath@single@split^3 * #1 + 3 * \spath@single@split^2 * (1 - \spath@single@split) * #3 + 3 * \spath@single@split * (1 - \spath@single@split)^2 * #5 + (1 - \spath@single@split)^3 * #7}
  \pgfmathsetmacro{\spath@ey}{\spath@single@split^3 * #2 + 3 * \spath@single@split^2 * (1 - \spath@single@split) * #4 + 3 * \spath@single@split * (1 - \spath@single@split)^2 * #6 + (1 - \spath@single@split)^3 * #8}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \ge@addto@macro\spath@tmppath\spath@to@add
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@single@split)*#7 + \spath@single@split * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@single@split)*#8 + \spath@single@split * #6}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@single@split)^2 * #7 + 2*\spath@single@split * (1 - \spath@single@split) * #5 + \spath@single@split^2 * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@single@split)^2 * #8 + 2*\spath@single@split * (1 - \spath@single@split) * #6 + \spath@single@split^2 * #4}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{#7}{#8}}
  \ge@addto@macro\spath@tmppath\spath@to@add
}
\def\spath@double@split{.5}
\def\spath@split@first@lineto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@linetotoken#3#4#5\relax{%
  \pgfmathsetmacro{\spath@sx}{(1-\spath@single@split)*#1 + \spath@single@split * #3}
  \pgfmathsetmacro{\spath@sy}{(1-\spath@single@split)*#2 + \spath@single@split * #4}
  \edef\spath@split@path@start{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@linetotoken{\spath@sx     pt}{\spath@sy pt}\noexpand\pgfsyssoftpath@linetotoken{#3}{#4}}
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@movetotoken{#3}{#4}}
  \g@addto@macro\spath@split@path@end{#5}
}
\def\spath@split@second@lineto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@linetotoken#3#4#5\relax{%
  \pgfmathsetmacro{\spath@sx}{(1-\spath@single@split)*#3 + \spath@single@split * #1}
  \pgfmathsetmacro{\spath@sy}{(1-\spath@single@split)*#4 + \spath@single@split * #2}
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@linetotoken{\spath@sx pt}{\spath@sy pt}\noexpand\pgfsyssoftpath@linetotoken{#3}{#4}}
}
\def\spath@split@first@curveto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)*#1 + \spath@double@split * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)*#2 + \spath@double@split * #4}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)^2 * #1 + 2*\spath@double@split * (1 - \spath@double@split) * #3 + \spath@double@split^2 * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)^2 * #2 + 2*\spath@double@split * (1 - \spath@double@split) * #4 + \spath@double@split^2 * #6}
  \pgfmathsetmacro{\spath@ex}{(1 - \spath@double@split)^3 * #1 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #3 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #5 + \spath@double@split^3 * #7}
  \pgfmathsetmacro{\spath@ey}{(1 - \spath@double@split)^3 * #2 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #4 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #6 + \spath@double@split^3 * #8}
  \edef\spath@split@path@start{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)*#5 + \spath@double@split * #7}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)*#6 + \spath@double@split * #8}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)^2 * #3 + 2*\spath@double@split * (1 - \spath@double@split) * #5 + \spath@double@split^2 * #7}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)^2 * #4 + 2*\spath@double@split * (1 - \spath@double@split) * #6 + \spath@double@split^2 * #8}

  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{#7}{#8}}
  \ge@addto@macro\spath@split@path@start\spath@to@add
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@movetotoken{#7}{#8}}
  \g@addto@macro\spath@split@path@end{#9}
}
\def\spath@split@second@curveto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)*#1 + \spath@double@split * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)*#2 + \spath@double@split * #4}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)^2 * #1 + 2*\spath@double@split * (1 - \spath@double@split) * #3 + \spath@double@split^2 * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)^2 * #2 + 2*\spath@double@split * (1 - \spath@double@split) * #4 + \spath@double@split^2 * #6}
  \pgfmathsetmacro{\spath@ex}{(1 - \spath@double@split)^3 * #1 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #3 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #5 + \spath@double@split^3 * #7}
  \pgfmathsetmacro{\spath@ey}{(1 - \spath@double@split)^3 * #2 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #4 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #6 + \spath@double@split^3 * #8}
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)*#5 + \spath@double@split * #7}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)*#6 + \spath@double@split * #8}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)^2 * #3 + 2*\spath@double@split * (1 - \spath@double@split) * #5 + \spath@double@split^2 * #7}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)^2 * #4 + 2*\spath@double@split * (1 - \spath@double@split) * #6 + \spath@double@split^2 * #8}

  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{#7}{#8}}
  \ge@addto@macro\spath@split@path@end\spath@to@add
}

%% 
%% Copyright (C) 2011 by Andrew Stacey <stacey@math.ntnu.no>
%% 
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License (LPPL), either
%% version 1.3c of this license or (at your option) any later
%% version.  The latest version of this license is in the file:
%% 
%% http://www.latex-project.org/lppl.txt
%% 
%% This work is "maintained" (as per LPPL maintenance status) by
%% Andrew Stacey.
%% 
%% This work consists of the file  spath.dtx
%% and the derived files           spath.ins,
%%                                 spath.pdf, and
%%                                 spath.sty.
%% 
%%
%% End of file `spath.sty'.
